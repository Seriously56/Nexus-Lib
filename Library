--========================================================
-- Nexus UI Library (Custom Linoria Replacement)
-- Complete UI Library with Nexus Design & Particles
--========================================================
local NexusUI = {}

-- Services
local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local UserInputService = game:GetService("UserInputService")
local TweenService = game:GetService("TweenService")
local TextService = game:GetService("TextService")
local CoreGui = game:GetService("CoreGui")

-- Local References
local LocalPlayer = Players.LocalPlayer
local Mouse = LocalPlayer:GetMouse()

-- ========================================
-- NEXUS COLOR SCHEME
-- ========================================
NexusUI.Colors = {
    Background = Color3.fromRGB(15, 8, 15),
    Surface = Color3.fromRGB(25, 15, 25),
    Primary = Color3.fromRGB(40, 25, 35),
    Secondary = Color3.fromRGB(40, 28, 38),
    Border = Color3.fromRGB(60, 40, 55),
    TextPrimary = Color3.fromRGB(255, 240, 245),
    TextSecondary = Color3.fromRGB(200, 170, 185),
    Success = Color3.fromRGB(100, 255, 150),
    Error = Color3.fromRGB(255, 100, 130),
    Warning = Color3.fromRGB(255, 200, 100),
    
    -- Nexus Pink Colors
    PinkLight = Color3.fromRGB(255, 182, 193),
    PinkMedium = Color3.fromRGB(255, 105, 180),
    PinkDark = Color3.fromRGB(255, 20, 147),
    PinkBright = Color3.fromRGB(255, 130, 190),
    PinkNeon = Color3.fromRGB(255, 60, 160),
    
    -- Hover Colors
    HoverPrimary = Color3.fromRGB(50, 35, 45),
    HoverSecondary = Color3.fromRGB(50, 38, 48)
}

-- ========================================
-- PARTICLE SYSTEM
-- ========================================
NexusUI.ParticleState = {
    Particles = {},
    IsDestroyed = false,
    MousePosition = {X = 0, Y = 0},
    GuiBounds = {MinX = 0, MaxX = 0, MinY = 0, MaxY = 0}
}

function NexusUI:UpdateGuiBounds(container)
    if not container then return end
    local absolutePosition = container.AbsolutePosition
    local absoluteSize = container.AbsoluteSize
    
    self.ParticleState.GuiBounds = {
        MinX = absolutePosition.X,
        MaxX = absolutePosition.X + absoluteSize.X,
        MinY = absolutePosition.Y,
        MaxY = absolutePosition.Y + absoluteSize.Y
    }
end

function NexusUI:CreateParticle(container)
    if not container or not container.Parent or self.ParticleState.IsDestroyed then
        return nil
    end
    
    local size = math.random(8, 24)
    local particle = Instance.new('Frame')
    particle.Size = UDim2.new(0, size, 0, size)
    
    local startX = math.random(0, 100) / 100
    local startY = math.random(0, 100) / 100
    particle.Position = UDim2.new(startX, 0, startY, 0)
    
    particle.BackgroundColor3 = self.Colors.PinkLight
    particle.BackgroundTransparency = math.random(60, 85) / 100
    particle.BorderSizePixel = 0
    particle.ZIndex = 5
    particle.Selectable = false
    particle.Parent = container
    
    local corner = Instance.new('UICorner')
    corner.CornerRadius = UDim.new(1, 0)
    corner.Parent = particle
    
    local gradient = Instance.new('UIGradient')
    local bubbleColors = {
        self.Colors.PinkLight,
        self.Colors.PinkMedium,
        self.Colors.PinkDark,
        Color3.fromRGB(255, 150, 200)
    }
    local color1 = bubbleColors[math.random(#bubbleColors)]
    local color2 = bubbleColors[math.random(#bubbleColors)]
    
    gradient.Color = ColorSequence.new({
        ColorSequenceKeypoint.new(0, color1),
        ColorSequenceKeypoint.new(0.3, Color3.fromRGB(255, 220, 230)),
        ColorSequenceKeypoint.new(0.7, color2),
        ColorSequenceKeypoint.new(1, color1)
    })
    gradient.Rotation = math.random(0, 360)
    gradient.Parent = particle
    
    local highlight = Instance.new('Frame')
    highlight.Size = UDim2.new(0.3, 0, 0.3, 0)
    highlight.Position = UDim2.new(0.2, 0, 0.15, 0)
    highlight.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
    highlight.BackgroundTransparency = 0.3
    highlight.BorderSizePixel = 0
    highlight.ZIndex = particle.ZIndex + 1
    highlight.Parent = particle
    
    local highlightCorner = Instance.new('UICorner')
    highlightCorner.CornerRadius = UDim.new(1, 0)
    highlightCorner.Parent = highlight
    
    local glow = Instance.new('Frame')
    glow.Size = UDim2.new(1.8, 0, 1.8, 0)
    glow.Position = UDim2.new(-0.4, 0, -0.4, 0)
    glow.BackgroundColor3 = self.Colors.PinkLight
    glow.BackgroundTransparency = 0.9
    glow.BorderSizePixel = 0
    glow.ZIndex = particle.ZIndex - 1
    glow.Parent = particle
    
    local glowCorner = Instance.new('UICorner')
    glowCorner.CornerRadius = UDim.new(1, 0)
    glowCorner.Parent = glow
    
    local particleData = {
        frame = particle,
        vx = (math.random() - 0.5) * 0.002,
        vy = (math.random() - 0.5) * 0.002,
        created = tick(),
        rotation = 0,
        rotationSpeed = (math.random() - 0.5) * 2,
        pulsePhase = math.random() * math.pi * 2,
        originalTransparency = particle.BackgroundTransparency,
        glow = glow,
        highlight = highlight,
        lifetime = math.random(30, 60),
        originalSize = size,
        wobblePhase = math.random() * math.pi * 2,
        repelForce = {x = 0, y = 0},
        mass = size / 10
    }
    
    table.insert(self.ParticleState.Particles, particleData)
    return particle
end

function NexusUI:UpdateParticles(container)
    if self.ParticleState.IsDestroyed or not container then return end
    
    self:UpdateGuiBounds(container)
    
    local screenSize = container.AbsoluteSize
    local mouseScreenX = (self.ParticleState.MousePosition.X - self.ParticleState.GuiBounds.MinX) / screenSize.X
    local mouseScreenY = (self.ParticleState.MousePosition.Y - self.ParticleState.GuiBounds.MinY) / screenSize.Y
    
    for i = #self.ParticleState.Particles, 1, -1 do
        local p = self.ParticleState.Particles[i]
        
        if not p or not p.frame or not p.frame.Parent then
            table.remove(self.ParticleState.Particles, i)
        else
            local currentPos = p.frame.Position
            local age = tick() - p.created
            
            if age > p.lifetime then
                p.frame:Destroy()
                table.remove(self.ParticleState.Particles, i)
            else
                local distanceToMouse = math.sqrt(
                    (currentPos.X.Scale - mouseScreenX)^2 + 
                    (currentPos.Y.Scale - mouseScreenY)^2
                )
                
                local repelStrength = 0.08
                local repelRadius = 0.15
                local repelForceX = 0
                local repelForceY = 0
                
                if distanceToMouse < repelRadius and distanceToMouse > 0 then
                    local repelPower = (repelRadius - distanceToMouse) / repelRadius
                    repelPower = repelPower * repelStrength / p.mass
                    
                    local directionX = (currentPos.X.Scale - mouseScreenX) / distanceToMouse
                    local directionY = (currentPos.Y.Scale - mouseScreenY) / distanceToMouse
                    
                    repelForceX = directionX * repelPower
                    repelForceY = directionY * repelPower
                end
                
                p.repelForce.x = p.repelForce.x * 0.85 + repelForceX * 0.15
                p.repelForce.y = p.repelForce.y * 0.85 + repelForceY * 0.15
                
                local newX = currentPos.X.Scale + p.vx + p.repelForce.x
                local newY = currentPos.Y.Scale + p.vy + p.repelForce.y
                
                if newX < 0 then newX = 0; p.vx = math.abs(p.vx) * 0.5 end
                if newX > 1 then newX = 1; p.vx = -math.abs(p.vx) * 0.5 end
                if newY < 0 then newY = 0; p.vy = math.abs(p.vy) * 0.5 end
                if newY > 1 then newY = 1; p.vy = -math.abs(p.vy) * 0.5 end
                
                local wobbleTime = tick() * 1.5 + p.wobblePhase
                newX = newX + math.sin(wobbleTime) * 0.001
                newY = newY + math.cos(wobbleTime * 0.7) * 0.001
                
                newX = newX + (math.random() - 0.5) * 0.0004
                newY = newY + (math.random() - 0.5) * 0.0003
                
                p.rotation = p.rotation + p.rotationSpeed
                p.frame.Rotation = p.rotation
                
                local breathe = math.sin(tick() * 2.5 + p.pulsePhase) * 0.1 + 1
                local currentSize = p.originalSize * breathe
                p.frame.Size = UDim2.new(0, currentSize, 0, currentSize)
                
                local transparencyPulse = math.sin(tick() * 3 + p.pulsePhase) * 0.1
                local newTransparency = math.max(0.5, math.min(0.95, p.originalTransparency + transparencyPulse))
                p.frame.BackgroundTransparency = newTransparency
                
                local glowIntensity = 0.9
                if distanceToMouse < 0.2 then
                    glowIntensity = 0.7 + (distanceToMouse / 0.2) * 0.2
                end
                p.glow.BackgroundTransparency = glowIntensity
                
                local shimmer = math.sin(tick() * 4 + p.pulsePhase) * 0.2 + 0.3
                p.highlight.BackgroundTransparency = shimmer
                
                p.vx = p.vx * 0.995
                p.vy = p.vy * 0.998
                
                p.frame.Position = UDim2.new(newX, 0, newY, 0)
            end
        end
    end
end

function NexusUI:StartParticleSystem(container)
    self:UpdateGuiBounds(container)
    
    UserInputService.InputChanged:Connect(function(input, gameProcessed)
        if input.UserInputType == Enum.UserInputType.MouseMovement then
            local mousePos = input.Position
            if mousePos.X >= self.ParticleState.GuiBounds.MinX and mousePos.X <= self.ParticleState.GuiBounds.MaxX and
               mousePos.Y >= self.ParticleState.GuiBounds.MinY and mousePos.Y <= self.ParticleState.GuiBounds.MaxY then
                self.ParticleState.MousePosition.X = mousePos.X
                self.ParticleState.MousePosition.Y = mousePos.Y
            end
        end
    end)
    
    task.spawn(function()
        for i = 1, 20 do
            if self.ParticleState.IsDestroyed then break end
            self:CreateParticle(container)
            task.wait(math.random(20, 100) / 1000)
        end
        
        while not self.ParticleState.IsDestroyed and container.Parent do
            if #self.ParticleState.Particles < 40 then
                self:CreateParticle(container)
            end
            task.wait(math.random(400, 1200) / 1000)
        end
    end)
    
    task.spawn(function()
        while not self.ParticleState.IsDestroyed and container.Parent do
            pcall(function() self:UpdateParticles(container) end)
            task.wait(1/60)
        end
    end)
end

-- ========================================
-- CORE UI FUNCTIONS
-- ========================================
NexusUI.Toggles = {}
NexusUI.Options = {}
NexusUI.Labels = {}
NexusUI.Buttons = {}

function NexusUI:Create(className, properties)
    local instance = Instance.new(className)
    
    for property, value in pairs(properties) do
        if property == "Size" or property == "Position" then
            instance[property] = value
        elseif property == "TextSize" then
            instance[property] = value
        else
            local success = pcall(function()
                instance[property] = value
            end)
        end
    end
    
    return instance
end

function NexusUI:CreateLabel(properties)
    local label = self:Create('TextLabel', {
        BackgroundTransparency = 1,
        Font = Enum.Font.Gotham,
        TextColor3 = self.Colors.TextPrimary,
        TextSize = 14,
        TextStrokeTransparency = 0,
    })
    
    for property, value in pairs(properties) do
        label[property] = value
    end
    
    return label
end

function NexusUI:MakeDraggable(frame, dragPart)
    dragPart = dragPart or frame
    local dragging = false
    local dragInput, dragStart, startPos
    
    dragPart.InputBegan:Connect(function(input)
        if input.UserInputType == Enum.UserInputType.MouseButton1 then
            dragging = true
            dragStart = input.Position
            startPos = frame.Position
            
            input.Changed:Connect(function()
                if input.UserInputState == Enum.UserInputState.End then
                    dragging = false
                end
            end)
        end
    end)
    
    dragPart.InputChanged:Connect(function(input)
        if input.UserInputType == Enum.UserInputType.MouseMovement then
            dragInput = input
        end
    end)
    
    UserInputService.InputChanged:Connect(function(input)
        if input == dragInput and dragging then
            local delta = input.Position - dragStart
            frame.Position = UDim2.new(
                startPos.X.Scale,
                startPos.X.Offset + delta.X,
                startPos.Y.Scale,
                startPos.Y.Offset + delta.Y
            )
        end
    end)
end

-- ========================================
-- WINDOW CREATION
-- ========================================
function NexusUI:CreateWindow(config)
    config = config or {}
    local window = {
        Tabs = {},
        ActiveTab = nil,
        Visible = true
    }
    
    -- Create ScreenGui
    local screenGui = self:Create("ScreenGui", {
        Name = "NexusUI",
        Parent = CoreGui,
        ResetOnSpawn = false,
        ZIndexBehavior = Enum.ZIndexBehavior.Sibling
    })
    
    -- Main Container
    local mainContainer = self:Create("Frame", {
        Name = "MainContainer",
        Size = config.Size or UDim2.new(0, 500, 0, 400),
        Position = config.Position or UDim2.new(0.5, -250, 0.5, -200),
        BackgroundColor3 = self.Colors.Surface,
        BackgroundTransparency = 0,
        BorderSizePixel = 0,
        ZIndex = 1000,
        Parent = screenGui
    })
    
    local corner = self:Create("UICorner", {
        CornerRadius = UDim.new(0, 20),
        Parent = mainContainer
    })
    
    local stroke = self:Create("UIStroke", {
        Color = self.Colors.PinkMedium,
        Thickness = 2,
        Transparency = 0.2,
        Parent = mainContainer
    })
    
    -- Particle Container
    local particleContainer = self:Create("Frame", {
        Size = UDim2.new(1, 0, 1, 0),
        BackgroundTransparency = 1,
        ZIndex = 5,
        Parent = mainContainer
    })
    
    -- Animated Border
    local animatedBorder = self:Create("Frame", {
        Name = "AnimatedBorder",
        Size = UDim2.new(1, 8, 1, 8),
        Position = UDim2.new(0, -4, 0, -4),
        BackgroundTransparency = 1,
        ZIndex = 999,
        Parent = mainContainer
    })
    
    local borderCorner = self:Create("UICorner", {
        CornerRadius = UDim.new(0, 24),
        Parent = animatedBorder
    })
    
    local borderStroke = self:Create("UIStroke", {
        Color = self.Colors.PinkLight,
        Thickness = 3,
        Transparency = 0.3,
        Parent = animatedBorder
    })
    
    local borderGradient = self:Create("UIGradient", {
        Color = ColorSequence.new{
            ColorSequenceKeypoint.new(0, self.Colors.PinkLight),
            ColorSequenceKeypoint.new(0.3, self.Colors.PinkMedium),
            ColorSequenceKeypoint.new(0.7, self.Colors.PinkDark),
            ColorSequenceKeypoint.new(1, self.Colors.PinkLight)
        },
        Transparency = NumberSequence.new{
            NumberSequenceKeypoint.new(0, 0.8),
            NumberSequenceKeypoint.new(0.2, 0.1),
            NumberSequenceKeypoint.new(0.8, 0.1),
            NumberSequenceKeypoint.new(1, 0.8)
        },
        Parent = borderStroke
    })
    
    -- Start border animation
    local borderTween = TweenService:Create(borderGradient, 
        TweenInfo.new(4, Enum.EasingStyle.Linear, Enum.EasingDirection.InOut, -1), 
        {Rotation = 360})
    borderTween:Play()
    
    -- Header
    local header = self:Create("Frame", {
        Name = "Header",
        Size = UDim2.new(1, 0, 0, 60),
        BackgroundTransparency = 1,
        ZIndex = 1001,
        Parent = mainContainer
    })
    
    local titleLabel = self:CreateLabel({
        Size = UDim2.new(1, -40, 1, 0),
        Position = UDim2.new(0, 20, 0, 0),
        Text = config.Title or "NEXUS UI",
        TextScaled = true,
        Font = Enum.Font.GothamBlack,
        TextColor3 = self.Colors.TextPrimary,
        TextStrokeTransparency = 0.7,
        TextStrokeColor3 = self.Colors.PinkDark,
        ZIndex = 1002,
        Parent = header
    })
    
    local titleGradient = self:Create("UIGradient", {
        Color = ColorSequence.new{
            ColorSequenceKeypoint.new(0, self.Colors.PinkLight),
            ColorSequenceKeypoint.new(0.5, self.Colors.PinkMedium),
            ColorSequenceKeypoint.new(1, self.Colors.PinkDark)
        },
        Rotation = 45,
        Parent = titleLabel
    })
    
    -- Tab Container
    local tabContainer = self:Create("Frame", {
        Name = "TabContainer",
        Size = UDim2.new(1, -40, 1, -80),
        Position = UDim2.new(0, 20, 0, 70),
        BackgroundTransparency = 1,
        ZIndex = 1001,
        Parent = mainContainer
    })
    
    -- Make draggable
    self:MakeDraggable(mainContainer, header)
    
    -- Start particle system
    self:StartParticleSystem(particleContainer)
    
    -- Window methods
    function window:SetTitle(newTitle)
        titleLabel.Text = newTitle
    end
    
    function window:ToggleVisibility()
        window.Visible = not window.Visible
        mainContainer.Visible = window.Visible
    end
    
    function window:AddTab(tabName)
        local tab = {
            Name = tabName,
            Groupboxes = {},
            Visible = false
        }
        
        -- This is where you'd add tab creation logic
        -- For now, we'll just store the tab
        table.insert(window.Tabs, tab)
        
        if #window.Tabs == 1 then
            window.ActiveTab = tab
            tab.Visible = true
        end
        
        return tab
    end
    
    function window:Destroy()
        screenGui:Destroy()
        self.ParticleState.IsDestroyed = true
    end
    
    window.Gui = screenGui
    window.MainContainer = mainContainer
    window.ParticleContainer = particleContainer
    
    return window
end

-- ========================================
-- GROUPBOX CREATION
-- ========================================
function NexusUI:CreateGroupbox(parent, config)
    config = config or {}
    local groupbox = {
        Elements = {},
        Visible = true
    }
    
    local groupboxFrame = self:Create("Frame", {
        Size = config.Size or UDim2.new(1, 0, 0, 200),
        BackgroundColor3 = self.Colors.Primary,
        BorderSizePixel = 0,
        ZIndex = 1002,
        Parent = parent
    })
    
    local corner = self:Create("UICorner", {
        CornerRadius = UDim.new(0, 12),
        Parent = groupboxFrame
    })
    
    local stroke = self:Create("UIStroke", {
        Color = self.Colors.Border,
        Thickness = 1,
        Parent = groupboxFrame
    })
    
    local titleLabel = self:CreateLabel({
        Size = UDim2.new(1, -20, 0, 30),
        Position = UDim2.new(0, 10, 0, 5),
        Text = config.Title or "Groupbox",
        TextColor3 = self.Colors.TextPrimary,
        TextSize = 16,
        Font = Enum.Font.GothamBold,
        ZIndex = 1003,
        Parent = groupboxFrame
    })
    
    local contentFrame = self:Create("Frame", {
        Size = UDim2.new(1, -20, 1, -40),
        Position = UDim2.new(0, 10, 0, 35),
        BackgroundTransparency = 1,
        ZIndex = 1002,
        Parent = groupboxFrame
    })
    
    local layout = self:Create("UIListLayout", {
        Padding = UDim.new(0, 5),
        SortOrder = Enum.SortOrder.LayoutOrder,
        Parent = contentFrame
    })
    
    -- Groupbox methods
    function groupbox:AddLabel(text)
        local label = self:CreateLabel({
            Size = UDim2.new(1, 0, 0, 20),
            Text = text,
            TextColor3 = self.Colors.TextSecondary,
            TextSize = 14,
            Font = Enum.Font.Gotham,
            ZIndex = 1003,
            Parent = contentFrame
        })
        
        table.insert(groupbox.Elements, label)
        return label
    end
    
    function groupbox:AddButton(config)
        config = config or {}
        local button = {}
        
        local buttonFrame = self:Create("TextButton", {
            Size = UDim2.new(1, 0, 0, 30),
            BackgroundColor3 = self.Colors.PinkMedium,
            BorderSizePixel = 0,
            Text = config.Text or "Button",
            TextColor3 = self.Colors.TextPrimary,
            TextSize = 14,
            Font = Enum.Font.Gotham,
            AutoButtonColor = false,
            ZIndex = 1003,
            Parent = contentFrame
        })
        
        local corner = self:Create("UICorner", {
            CornerRadius = UDim.new(0, 8),
            Parent = buttonFrame
        })
        
        -- Hover effects
        buttonFrame.MouseEnter:Connect(function()
            TweenService:Create(buttonFrame, TweenInfo.new(0.2), {
                BackgroundColor3 = self.Colors.PinkBright
            }):Play()
        end)
        
        buttonFrame.MouseLeave:Connect(function()
            TweenService:Create(buttonFrame, TweenInfo.new(0.2), {
                BackgroundColor3 = self.Colors.PinkMedium
            }):Play()
        end)
        
        buttonFrame.MouseButton1Click:Connect(function()
            if config.Callback then
                config.Callback()
            end
        end)
        
        function button:SetText(newText)
            buttonFrame.Text = newText
        end
        
        function button:SetVisible(visible)
            buttonFrame.Visible = visible
        end
        
        table.insert(groupbox.Elements, button)
        table.insert(self.Buttons, button)
        
        return button
    end
    
    function groupbox:AddToggle(config)
        config = config or {}
        local toggle = {
            Value = config.Default or false,
            Type = "Toggle"
        }
        
        local toggleFrame = self:Create("Frame", {
            Size = UDim2.new(1, 0, 0, 30),
            BackgroundTransparency = 1,
            ZIndex = 1003,
            Parent = contentFrame
        })
        
        local toggleButton = self:Create("TextButton", {
            Size = UDim2.new(0, 20, 0, 20),
            Position = UDim2.new(0, 0, 0, 5),
            BackgroundColor3 = self.Colors.Primary,
            BorderSizePixel = 0,
            Text = "",
            AutoButtonColor = false,
            ZIndex = 1004,
            Parent = toggleFrame
        })
        
        local toggleCorner = self:Create("UICorner", {
            CornerRadius = UDim.new(0, 4),
            Parent = toggleButton
        })
        
        local toggleStroke = self:Create("UIStroke", {
            Color = self.Colors.Border,
            Thickness = 1,
            Parent = toggleButton
        })
        
        local toggleLabel = self:CreateLabel({
            Size = UDim2.new(1, -25, 1, 0),
            Position = UDim2.new(0, 25, 0, 0),
            Text = config.Text or "Toggle",
            TextColor3 = self.Colors.TextPrimary,
            TextSize = 14,
            Font = Enum.Font.Gotham,
            TextXAlignment = Enum.TextXAlignment.Left,
            ZIndex = 1004,
            Parent = toggleFrame
        })
        
        local function updateToggle()
            if toggle.Value then
                toggleButton.BackgroundColor3 = self.Colors.PinkMedium
            else
                toggleButton.BackgroundColor3 = self.Colors.Primary
            end
        end
        
        toggleButton.MouseButton1Click:Connect(function()
            toggle.Value = not toggle.Value
            updateToggle()
            
            if config.Callback then
                config.Callback(toggle.Value)
            end
            
            if config.Changed then
                config.Changed(toggle.Value)
            end
        end)
        
        function toggle:SetValue(value)
            toggle.Value = value
            updateToggle()
        end
        
        function toggle:OnChanged(callback)
            config.Changed = callback
        end
        
        updateToggle()
        table.insert(groupbox.Elements, toggle)
        table.insert(self.Toggles, toggle)
        
        return toggle
    end
    
    function groupbox:AddSlider(config)
        config = config or {}
        local slider = {
            Value = config.Default or config.Min or 0,
            Min = config.Min or 0,
            Max = config.Max or 100,
            Type = "Slider"
        }
        
        local sliderFrame = self:Create("Frame", {
            Size = UDim2.new(1, 0, 0, 50),
            BackgroundTransparency = 1,
            ZIndex = 1003,
            Parent = contentFrame
        })
        
        local sliderLabel = self:CreateLabel({
            Size = UDim2.new(1, 0, 0, 20),
            Text = config.Text or "Slider",
            TextColor3 = self.Colors.TextPrimary,
            TextSize = 14,
            Font = Enum.Font.Gotham,
            ZIndex = 1004,
            Parent = sliderFrame
        })
        
        local valueLabel = self:CreateLabel({
            Size = UDim2.new(0, 60, 0, 20),
            Position = UDim2.new(1, -60, 0, 0),
            Text = tostring(slider.Value),
            TextColor3 = self.Colors.TextSecondary,
            TextSize = 12,
            Font = Enum.Font.Gotham,
            TextXAlignment = Enum.TextXAlignment.Right,
            ZIndex = 1004,
            Parent = sliderFrame
        })
        
        local trackFrame = self:Create("Frame", {
            Size = UDim2.new(1, 0, 0, 4),
            Position = UDim2.new(0, 0, 0, 25),
            BackgroundColor3 = self.Colors.Primary,
            BorderSizePixel = 0,
            ZIndex = 1004,
            Parent = sliderFrame
        })
        
        local trackCorner = self:Create("UICorner", {
            CornerRadius = UDim.new(1, 0),
            Parent = trackFrame
        })
        
        local fillFrame = self:Create("Frame", {
            Size = UDim2.new(0, 0, 1, 0),
            BackgroundColor3 = self.Colors.PinkMedium,
            BorderSizePixel = 0,
            ZIndex = 1005,
            Parent = trackFrame
        })
        
        local fillCorner = self:Create("UICorner", {
            CornerRadius = UDim.new(1, 0),
            Parent = fillFrame
        })
        
        local thumbFrame = self:Create("Frame", {
            Size = UDim2.new(0, 12, 0, 12),
            Position = UDim2.new(0, 0, 0.5, -6),
            BackgroundColor3 = self.Colors.PinkBright,
            BorderSizePixel = 0,
            ZIndex = 1006,
            Parent = trackFrame
        })
        
        local thumbCorner = self:Create("UICorner", {
            CornerRadius = UDim.new(1, 0),
            Parent = thumbFrame
        })
        
        local function updateSlider()
            local percentage = (slider.Value - slider.Min) / (slider.Max - slider.Min)
            fillFrame.Size = UDim2.new(percentage, 0, 1, 0)
            thumbFrame.Position = UDim2.new(percentage, -6, 0.5, -6)
            valueLabel.Text = tostring(slider.Value)
        end
        
        local dragging = false
        trackFrame.InputBegan:Connect(function(input)
            if input.UserInputType == Enum.UserInputType.MouseButton1 then
                dragging = true
                
                local connection
                connection = RunService.Heartbeat:Connect(function()
                    if not dragging then
                        connection:Disconnect()
                        return
                    end
                    
                    local mousePos = UserInputService:GetMouseLocation()
                    local trackAbsPos = trackFrame.AbsolutePosition
                    local trackAbsSize = trackFrame.AbsoluteSize
                    
                    local relativeX = (mousePos.X - trackAbsPos.X) / trackAbsSize.X
                    relativeX = math.clamp(relativeX, 0, 1)
                    
                    slider.Value = math.floor(slider.Min + (slider.Max - slider.Min) * relativeX)
                    updateSlider()
                    
                    if config.Callback then
                        config.Callback(slider.Value)
                    end
                    
                    if config.Changed then
                        config.Changed(slider.Value)
                    end
                end)
                
                input.Changed:Connect(function()
                    if input.UserInputState == Enum.UserInputState.End then
                        dragging = false
                    end
                end)
            end
        end)
        
        function slider:SetValue(value)
            slider.Value = math.clamp(value, slider.Min, slider.Max)
            updateSlider()
        end
        
        function slider:OnChanged(callback)
            config.Changed = callback
        end
        
        updateSlider()
        table.insert(groupbox.Elements, slider)
        table.insert(self.Options, slider)
        
        return slider
    end
    
    function groupbox:AddDropdown(config)
        config = config or {}
        local dropdown = {
            Value = config.Default,
            Values = config.Values or {},
            Type = "Dropdown",
            Open = false
        }
        
        local dropdownFrame = self:Create("Frame", {
            Size = UDim2.new(1, 0, 0, 30),
            BackgroundTransparency = 1,
            ZIndex = 1003,
            Parent = contentFrame
        })
        
        local dropdownButton = self:Create("TextButton", {
            Size = UDim2.new(1, 0, 0, 30),
            BackgroundColor3 = self.Colors.Primary,
            BorderSizePixel = 0,
            Text = dropdown.Value or "Select...",
            TextColor3 = self.Colors.TextPrimary,
            TextSize = 14,
            Font = Enum.Font.Gotham,
            AutoButtonColor = false,
            ZIndex = 1004,
            Parent = dropdownFrame
        })
        
        local dropdownCorner = self:Create("UICorner", {
            CornerRadius = UDim.new(0, 6),
            Parent = dropdownButton
        })
        
        local dropdownList = self:Create("ScrollingFrame", {
            Size = UDim2.new(1, 0, 0, 0),
            Position = UDim2.new(0, 0, 1, 2),
            BackgroundColor3 = self.Colors.Primary,
            BorderSizePixel = 0,
            ScrollBarThickness = 3,
            ScrollBarImageColor3 = self.Colors.PinkMedium,
            CanvasSize = UDim2.new(0, 0, 0, 0),
            Visible = false,
            ZIndex = 1010,
            Parent = dropdownFrame
        })
        
        local listLayout = self:Create("UIListLayout", {
            SortOrder = Enum.SortOrder.LayoutOrder,
            Parent = dropdownList
        })
        
        local function updateDropdown()
            dropdownButton.Text = dropdown.Value or "Select..."
            dropdownList.Visible = dropdown.Open
            
            if dropdown.Open then
                TweenService:Create(dropdownList, TweenInfo.new(0.2), {
                    Size = UDim2.new(1, 0, 0, math.min(#dropdown.Values * 30, 150))
                }):Play()
            else
                TweenService:Create(dropdownList, TweenInfo.new(0.2), {
                    Size = UDim2.new(1, 0, 0, 0)
                }):Play()
            end
        end
        
        local function createOption(option)
            local optionButton = self:Create("TextButton", {
                Size = UDim2.new(1, 0, 0, 30),
                BackgroundColor3 = self.Colors.Primary,
                BorderSizePixel = 0,
                Text = option,
                TextColor3 = self.Colors.TextPrimary,
                TextSize = 14,
                Font = Enum.Font.Gotham,
                AutoButtonColor = false,
                ZIndex = 1011,
                Parent = dropdownList
            })
            
            optionButton.MouseEnter:Connect(function()
                TweenService:Create(optionButton, TweenInfo.new(0.2), {
                    BackgroundColor3 = self.Colors.HoverPrimary
                }):Play()
            end)
            
            optionButton.MouseLeave:Connect(function()
                TweenService:Create(optionButton, TweenInfo.new(0.2), {
                    BackgroundColor3 = self.Colors.Primary
                }):Play()
            end)
            
            optionButton.MouseButton1Click:Connect(function()
                dropdown.Value = option
                dropdown.Open = false
                updateDropdown()
                
                if config.Callback then
                    config.Callback(option)
                end
                
                if config.Changed then
                    config.Changed(option)
                end
            end)
        end
        
        for _, option in ipairs(dropdown.Values) do
            createOption(option)
        end
        
        dropdownList.CanvasSize = UDim2.new(0, 0, 0, #dropdown.Values * 30)
        
        dropdownButton.MouseButton1Click:Connect(function()
            dropdown.Open = not dropdown.Open
            updateDropdown()
        end)
        
        function dropdown:SetValue(value)
            dropdown.Value = value
            updateDropdown()
        end
        
        function dropdown:SetOptions(options)
            dropdown.Values = options
            dropdownList:ClearAllChildren()
            dropdownList:AddChild(listLayout)
            
            for _, option in ipairs(options) do
                createOption(option)
            end
            
            dropdownList.CanvasSize = UDim2.new(0, 0, 0, #options * 30)
        end
        
        function dropdown:OnChanged(callback)
            config.Changed = callback
        end
        
        updateDropdown()
        table.insert(groupbox.Elements, dropdown)
        table.insert(self.Options, dropdown)
        
        return dropdown
    end
    
    function groupbox:SetVisible(visible)
        groupboxFrame.Visible = visible
        groupbox.Visible = visible
    end
    
    groupbox.Frame = groupboxFrame
    groupbox.ContentFrame = contentFrame
    
    return groupbox
end

-- ========================================
-- NOTIFICATION SYSTEM
-- ========================================
function NexusUI:Notify(title, message, duration)
    duration = duration or 5
    
    local notificationGui = self:Create("ScreenGui", {
        Name = "Notification",
        Parent = CoreGui,
        ZIndexBehavior = Enum.ZIndexBehavior.Sibling
    })
    
    local notificationFrame = self:Create("Frame", {
        Size = UDim2.new(0, 300, 0, 80),
        Position = UDim2.new(1, -320, 1, -100),
        BackgroundColor3 = self.Colors.Surface,
        BorderSizePixel = 0,
        ZIndex = 2000,
        Parent = notificationGui
    })
    
    local corner = self:Create("UICorner", {
        CornerRadius = UDim.new(0, 12),
        Parent = notificationFrame
    })
    
    local stroke = self:Create("UIStroke", {
        Color = self.Colors.PinkMedium,
        Thickness = 2,
        Parent = notificationFrame
    })
    
    local titleLabel = self:CreateLabel({
        Size = UDim2.new(1, -20, 0, 25),
        Position = UDim2.new(0, 10, 0, 5),
        Text = title,
        TextColor3 = self.Colors.TextPrimary,
        TextSize = 16,
        Font = Enum.Font.GothamBold,
        ZIndex = 2001,
        Parent = notificationFrame
    })
    
    local messageLabel = self:CreateLabel({
        Size = UDim2.new(1, -20, 1, -35),
        Position = UDim2.new(0, 10, 0, 30),
        Text = message,
        TextColor3 = self.Colors.TextSecondary,
        TextSize = 14,
        Font = Enum.Font.Gotham,
        TextWrapped = true,
        ZIndex = 2001,
        Parent = notificationFrame
    })
    
    -- Entrance animation
    notificationFrame.Position = UDim2.new(1, 300, 1, -100)
    TweenService:Create(notificationFrame, TweenInfo.new(0.3, Enum.EasingStyle.Back), {
        Position = UDim2.new(1, -320, 1, -100)
    }):Play()
    
    -- Auto-remove after duration
    task.delay(duration, function()
        TweenService:Create(notificationFrame, TweenInfo.new(0.3, Enum.EasingStyle.Back), {
            Position = UDim2.new(1, 300, 1, -100)
        }):Play()
        
        task.wait(0.3)
        notificationGui:Destroy()
    end)
    
    return notificationGui
end

-- ========================================
-- INITIALIZATION
-- ========================================
function NexusUI:Init()
    -- Library is now ready to use
    self.Initialized = true
    return self
end

-- Initialize the library
NexusUI:Init()

-- Return the library
return NexusUI
