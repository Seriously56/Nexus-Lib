-- Nexus UI Library - Complete with Full Logic and Functionality
local UserInputService = game:GetService("UserInputService")
local RunService = game:GetService("RunService")
local TweenService = game:GetService("TweenService")
local Players = game:GetService("Players")
local TextService = game:GetService("TextService")
local HttpService = game:GetService("HttpService")
local TeleportService = game:GetService("TeleportService")
local MarketplaceService = game:GetService("MarketplaceService")

local Player = Players.LocalPlayer
local Mouse = Player:GetMouse()

-- ========================================
-- NEXUS COLOR SCHEME (MAX MONEY STYLE)
-- ========================================
local NexusColors = {
    Background = Color3.fromRGB(15, 8, 15),
    Surface = Color3.fromRGB(25, 15, 25),
    Primary = Color3.fromRGB(40, 25, 35),
    Secondary = Color3.fromRGB(40, 28, 38),
    Border = Color3.fromRGB(60, 40, 55),
    TextPrimary = Color3.fromRGB(255, 240, 245),
    TextSecondary = Color3.fromRGB(200, 170, 185),
    Success = Color3.fromRGB(100, 255, 150),
    Error = Color3.fromRGB(255, 100, 130),
    Warning = Color3.fromRGB(255, 200, 100),
    Accent = Color3.fromRGB(255, 105, 180),
    AccentDark = Color3.fromRGB(200, 65, 150),
    AccentLight = Color3.fromRGB(255, 182, 193),
    ButtonPrimary = Color3.fromRGB(255, 105, 180),
    ButtonSecondary = Color3.fromRGB(180, 65, 160),
    HoverPrimary = Color3.fromRGB(50, 35, 45),
    HoverAccent = Color3.fromRGB(255, 120, 200),
    HoverSecondary = Color3.fromRGB(200, 85, 180),
    Disabled = Color3.fromRGB(100, 100, 100),
    DisabledText = Color3.fromRGB(150, 150, 150)
}

-- ========================================
-- NEXUS UI LIBRARY CORE
-- ========================================
local NexusUI = {
    Toggles = {},
    Options = {},
    Labels = {},
    Buttons = {},
    Registry = {},
    OpenedFrames = {},
    ActiveTab = nil,
    Toggled = false,
    IsMobile = (UserInputService.TouchEnabled and not UserInputService.MouseEnabled),
    CanDrag = true,
    ShowCustomCursor = true,
    AutoFarmLoops = {},
    ESPHandles = {},
    WhitelistedPlayers = {},
    BlacklistedPlayers = {},
    AimbotTarget = nil,
    SilentAimTarget = nil
}

-- Screen GUI Setup
local ScreenGui = Instance.new("ScreenGui")
ScreenGui.Name = "NexusUILibrary"
ScreenGui.ZIndexBehavior = Enum.ZIndexBehavior.Global
ScreenGui.DisplayOrder = 999
ScreenGui.ResetOnSpawn = false
ScreenGui.Parent = Player:WaitForChild("PlayerGui")

NexusUI.ScreenGui = ScreenGui

-- ========================================
-- GAME-SPECIFIC LOGIC MODULES
-- ========================================
local GameLogic = {
    AutoFarm = {
        Active = false,
        Connections = {},
        LastFarmTime = 0
    },
    
    ESP = {
        Enabled = false,
        Boxes = {},
        NameTags = {},
        Tracers = {}
    },
    
    Aimbot = {
        Enabled = false,
        Smoothness = 0.1,
        FOV = 50,
        TargetPart = "Head",
        TeamCheck = true,
        WallCheck = true
    },
    
    SilentAim = {
        Enabled = false,
        HitChance = 100,
        TargetPart = "Head"
    },
    
    Combat = {
        AutoClicker = false,
        Reach = 25,
        HitBox = 1,
        AutoBlock = false
    },
    
    Movement = {
        Speed = 16,
        JumpPower = 50,
        FlyEnabled = false,
        Noclip = false,
        InfiniteJump = false
    },
    
    Player = {
        GodMode = false,
        AntiAfk = false,
        AutoRespawn = false,
        NoFallDamage = false
    },
    
    Misc = {
        AutoCollect = false,
        AutoSell = false,
        AntiKick = false,
        ServerHop = false
    }
}

-- ========================================
-- UTILITY FUNCTIONS
-- ========================================
function NexusUI:Create(className, properties)
    local instance = Instance.new(className)
    for property, value in pairs(properties) do
        instance[property] = value
    end
    return instance
end

function NexusUI:AddToRegistry(instance, properties)
    table.insert(self.Registry, {
        Instance = instance,
        Properties = properties
    })
end

function NexusUI:ApplyNexusStyle(frame, styleType)
    local corner = self:Create("UICorner", {
        CornerRadius = UDim.new(0, 8),
        Parent = frame
    })
    
    if styleType == "main" then
        frame.BackgroundColor3 = NexusColors.Surface
        local stroke = self:Create("UIStroke", {
            Color = NexusColors.Accent,
            Thickness = 1,
            Transparency = 0.3,
            Parent = frame
        })
    elseif styleType == "button" then
        frame.BackgroundColor3 = NexusColors.ButtonPrimary
        frame.TextColor3 = NexusColors.TextPrimary
        frame.Font = Enum.Font.GothamBold
    elseif styleType == "section" then
        frame.BackgroundColor3 = NexusColors.Primary
    end
    
    return frame
end

function NexusUI:CreateGradient(parent, colors, rotation)
    local gradient = self:Create("UIGradient", {
        Color = ColorSequence.new(colors),
        Rotation = rotation or 90,
        Parent = parent
    })
    return gradient
end

function NexusUI:CreateLabel(properties)
    local label = self:Create("TextLabel", {
        BackgroundTransparency = 1,
        Font = Enum.Font.Gotham,
        TextColor3 = NexusColors.TextPrimary,
        TextSize = 14,
        TextStrokeTransparency = 0.8,
        TextXAlignment = Enum.TextXAlignment.Left
    })
    
    for property, value in pairs(properties) do
        label[property] = value
    end
    
    return label
end

function NexusUI:AddHoverEffect(button, normalColor, hoverColor)
    button.MouseEnter:Connect(function()
        TweenService:Create(button, TweenInfo.new(0.2), {
            BackgroundColor3 = hoverColor
        }):Play()
    end)
    
    button.MouseLeave:Connect(function()
        TweenService:Create(button, TweenInfo.new(0.2), {
            BackgroundColor3 = normalColor
        }):Play()
    end)
end

function NexusUI:SafeCallback(callback, ...)
    if callback and type(callback) == "function" then
        pcall(callback, ...)
    end
end

-- ========================================
-- GAME LOGIC FUNCTIONS
-- ========================================
function GameLogic:StartAutoFarm()
    if GameLogic.AutoFarm.Active then return end
    
    GameLogic.AutoFarm.Active = true
    NexusUI:Notify("Auto Farm Started", 3)
    
    local farmLoop = RunService.Heartbeat:Connect(function()
        if not GameLogic.AutoFarm.Active then return end
        
        -- Auto farm logic (game-specific)
        local character = Player.Character
        if not character then return end
        
        local humanoid = character:FindFirstChild("Humanoid")
        local rootPart = character:FindFirstChild("HumanoidRootPart")
        
        if not humanoid or not rootPart then return end
        
        -- Find nearest target (coins, enemies, etc.)
        local nearestTarget = nil
        local nearestDistance = math.huge
        
        for _, item in pairs(workspace:GetChildren()) do
            if item:IsA("Part") and item.Name == "Coin" then
                local distance = (rootPart.Position - item.Position).Magnitude
                if distance < nearestDistance then
                    nearestDistance = distance
                    nearestTarget = item
                end
            end
        end
        
        if nearestTarget and nearestDistance < 50 then
            -- Move to target
            humanoid:MoveTo(nearestTarget.Position)
            
            -- Collect if close enough
            if nearestDistance < 10 then
                firetouchinterest(rootPart, nearestTarget, 0)
                firetouchinterest(rootPart, nearestTarget, 1)
            end
        end
    end)
    
    table.insert(GameLogic.AutoFarm.Connections, farmLoop)
end

function GameLogic:StopAutoFarm()
    GameLogic.AutoFarm.Active = false
    for _, connection in pairs(GameLogic.AutoFarm.Connections) do
        connection:Disconnect()
    end
    GameLogic.AutoFarm.Connections = {}
    NexusUI:Notify("Auto Farm Stopped", 3)
end

function GameLogic:ToggleESP()
    GameLogic.ESP.Enabled = not GameLogic.ESP.Enabled
    
    if GameLogic.ESP.Enabled then
        NexusUI:Notify("ESP Enabled", 3)
        GameLogic:CreateESP()
    else
        NexusUI:Notify("ESP Disabled", 3)
        GameLogic:ClearESP()
    end
end

function GameLogic:CreateESP()
    for _, player in pairs(Players:GetPlayers()) do
        if player ~= Player then
            GameLogic:CreateESPForPlayer(player)
        end
    end
    
    -- Listen for new players
    Players.PlayerAdded:Connect(function(player)
        if GameLogic.ESP.Enabled then
            GameLogic:CreateESPForPlayer(player)
        end
    end)
end

function GameLogic:CreateESPForPlayer(player)
    local character = player.Character or player.CharacterAdded:Wait()
    
    -- Create ESP Box
    local box = Instance.new("BoxHandleAdornment")
    box.Name = "NexusESPBox"
    box.Adornee = character:WaitForChild("HumanoidRootPart")
    box.AlwaysOnTop = true
    box.ZIndex = 10
    box.Size = Vector3.new(4, 6, 2)
    box.Color3 = NexusColors.Accent
    box.Transparency = 0.3
    box.Parent = character.HumanoidRootPart
    
    GameLogic.ESP.Boxes[player] = box
    
    -- Create Name Tag
    local billboard = Instance.new("BillboardGui")
    billboard.Name = "NexusESPName"
    billboard.Adornee = character.Head
    billboard.Size = UDim2.new(0, 200, 0, 50)
    billboard.StudsOffset = Vector3.new(0, 3, 0)
    billboard.AlwaysOnTop = true
    
    local nameLabel = Instance.new("TextLabel")
    nameLabel.Size = UDim2.new(1, 0, 1, 0)
    nameLabel.BackgroundTransparency = 1
    nameLabel.Text = player.Name
    nameLabel.TextColor3 = NexusColors.TextPrimary
    nameLabel.TextStrokeTransparency = 0
    nameLabel.TextSize = 14
    nameLabel.Font = Enum.Font.GothamBold
    nameLabel.Parent = billboard
    
    billboard.Parent = character.Head
    GameLogic.ESP.NameTags[player] = billboard
end

function GameLogic:ClearESP()
    for player, box in pairs(GameLogic.ESP.Boxes) do
        box:Destroy()
    end
    for player, tag in pairs(GameLogic.ESP.NameTags) do
        tag:Destroy()
    end
    GameLogic.ESP.Boxes = {}
    GameLogic.ESP.NameTags = {}
end

function GameLogic:ToggleAimbot()
    GameLogic.Aimbot.Enabled = not GameLogic.Aimbot.Enabled
    
    if GameLogic.Aimbot.Enabled then
        NexusUI:Notify("Aimbot Enabled", 3)
        GameLogic:StartAimbot()
    else
        NexusUI:Notify("Aimbot Disabled", 3)
        GameLogic.AimbotTarget = nil
    end
end

function GameLogic:StartAimbot()
    local aimbotLoop = RunService.Heartbeat:Connect(function()
        if not GameLogic.Aimbot.Enabled then return end
        
        local character = Player.Character
        if not character then return end
        
        local camera = workspace.CurrentCamera
        local mouse = Player:GetMouse()
        
        local target = GameLogic:GetAimbotTarget()
        if target then
            GameLogic.AimbotTarget = target
            local targetPos = target[GameLogic.Aimbot.TargetPart].Position
            
            -- Smooth aim
            local current = camera.CFrame
            local targetCF = CFrame.lookAt(current.Position, targetPos)
            camera.CFrame = current:Lerp(targetCF, GameLogic.Aimbot.Smoothness)
        else
            GameLogic.AimbotTarget = nil
        end
    end)
end

function GameLogic:GetAimbotTarget()
    local character = Player.Character
    if not character then return nil end
    
    local camera = workspace.CurrentCamera
    local mouse = Player:GetMouse()
    
    local closestTarget = nil
    local closestDistance = math.huge
    
    for _, player in pairs(Players:GetPlayers()) do
        if player ~= Player and player.Character then
            local targetChar = player.Character
            local humanoid = targetChar:FindFirstChild("Humanoid")
            local rootPart = targetChar:FindFirstChild("HumanoidRootPart")
            
            if humanoid and humanoid.Health > 0 and rootPart then
                -- Team check
                if GameLogic.Aimbot.TeamCheck and player.Team == Player.Team then
                    continue
                end
                
                -- Wall check
                if GameLogic.Aimbot.WallCheck then
                    local ray = Ray.new(camera.CFrame.Position, (rootPart.Position - camera.CFrame.Position).Unit * 1000)
                    local hit, pos = workspace:FindPartOnRayWithIgnoreList(ray, {Player.Character, targetChar})
                    if hit and not hit:IsDescendantOf(targetChar) then
                        continue
                    end
                end
                
                -- FOV check
                local screenPoint, onScreen = camera:WorldToViewportPoint(rootPart.Position)
                if onScreen then
                    local distance = (Vector2.new(mouse.X, mouse.Y) - Vector2.new(screenPoint.X, screenPoint.Y)).Magnitude
                    if distance < GameLogic.Aimbot.FOV and distance < closestDistance then
                        closestDistance = distance
                        closestTarget = targetChar
                    end
                end
            end
        end
    end
    
    return closestTarget
end

function GameLogic:SetWalkSpeed(speed)
    GameLogic.Movement.Speed = speed
    local character = Player.Character
    if character then
        local humanoid = character:FindFirstChild("Humanoid")
        if humanoid then
            humanoid.WalkSpeed = speed
        end
    end
end

function GameLogic:SetJumpPower(power)
    GameLogic.Movement.JumpPower = power
    local character = Player.Character
    if character then
        local humanoid = character:FindFirstChild("Humanoid")
        if humanoid then
            humanoid.JumpPower = power
        end
    end
end

function GameLogic:ToggleFly()
    GameLogic.Movement.FlyEnabled = not GameLogic.Movement.FlyEnabled
    
    if GameLogic.Movement.FlyEnabled then
        NexusUI:Notify("Fly Enabled", 3)
        GameLogic:StartFlying()
    else
        NexusUI:Notify("Fly Disabled", 3)
        GameLogic:StopFlying()
    end
end

function GameLogic:StartFlying()
    local character = Player.Character
    if not character then return end
    
    local rootPart = character:FindFirstChild("HumanoidRootPart")
    local humanoid = character:FindFirstChild("Humanoid")
    if not rootPart or not humanoid then return end
    
    humanoid.PlatformStand = true
    
    local bodyVelocity = Instance.new("BodyVelocity")
    bodyVelocity.Velocity = Vector3.new(0, 0, 0)
    bodyVelocity.MaxForce = Vector3.new(40000, 40000, 40000)
    bodyVelocity.Parent = rootPart
    
    local flyLoop = RunService.Heartbeat:Connect(function()
        if not GameLogic.Movement.FlyEnabled or not character then
            bodyVelocity:Destroy()
            humanoid.PlatformStand = false
            return
        end
        
        local camera = workspace.CurrentCamera
        local moveDirection = Vector3.new(0, 0, 0)
        
        if UserInputService:IsKeyDown(Enum.KeyCode.W) then
            moveDirection = moveDirection + camera.CFrame.LookVector
        end
        if UserInputService:IsKeyDown(Enum.KeyCode.S) then
            moveDirection = moveDirection - camera.CFrame.LookVector
        end
        if UserInputService:IsKeyDown(Enum.KeyCode.A) then
            moveDirection = moveDirection - camera.CFrame.RightVector
        end
        if UserInputService:IsKeyDown(Enum.KeyCode.D) then
            moveDirection = moveDirection + camera.CFrame.RightVector
        end
        if UserInputService:IsKeyDown(Enum.KeyCode.Space) then
            moveDirection = moveDirection + Vector3.new(0, 1, 0)
        end
        if UserInputService:IsKeyDown(Enum.KeyCode.LeftShift) then
            moveDirection = moveDirection - Vector3.new(0, 1, 0)
        end
        
        bodyVelocity.Velocity = moveDirection.Unit * 50
    end)
    
    table.insert(GameLogic.AutoFarm.Connections, flyLoop)
end

function GameLogic:StopFlying()
    local character = Player.Character
    if character then
        local humanoid = character:FindFirstChild("Humanoid")
        local rootPart = character:FindFirstChild("HumanoidRootPart")
        
        if humanoid then
            humanoid.PlatformStand = false
        end
        
        if rootPart then
            local bodyVelocity = rootPart:FindFirstChild("BodyVelocity")
            if bodyVelocity then
                bodyVelocity:Destroy()
            end
        end
    end
end

function GameLogic:ToggleNoclip()
    GameLogic.Movement.Noclip = not GameLogic.Movement.Noclip
    
    if GameLogic.Movement.Noclip then
        NexusUI:Notify("Noclip Enabled", 3)
        GameLogic:StartNoclip()
    else
        NexusUI:Notify("Noclip Disabled", 3)
    end
end

function GameLogic:StartNoclip()
    local noclipLoop = RunService.Stepped:Connect(function()
        if not GameLogic.Movement.Noclip then return end
        
        local character = Player.Character
        if not character then return end
        
        for _, part in pairs(character:GetDescendants()) do
            if part:IsA("BasePart") and part.CanCollide then
                part.CanCollide = false
            end
        end
    end)
    
    table.insert(GameLogic.AutoFarm.Connections, noclipLoop)
end

function GameLogic:ToggleInfiniteJump()
    GameLogic.Movement.InfiniteJump = not GameLogic.Movement.InfiniteJump
    
    if GameLogic.Movement.InfiniteJump then
        NexusUI:Notify("Infinite Jump Enabled", 3)
        GameLogic:StartInfiniteJump()
    else
        NexusUI:Notify("Infinite Jump Disabled", 3)
    end
end

function GameLogic:StartInfiniteJump()
    local jumpConnection = UserInputService.JumpRequest:Connect(function()
        if GameLogic.Movement.InfiniteJump then
            local character = Player.Character
            if character then
                local humanoid = character:FindFirstChild("Humanoid")
                if humanoid then
                    humanoid:ChangeState(Enum.HumanoidStateType.Jumping)
                end
            end
        end
    end)
    
    table.insert(GameLogic.AutoFarm.Connections, jumpConnection)
end

function GameLogic:ToggleAutoClicker()
    GameLogic.Combat.AutoClicker = not GameLogic.Combat.AutoClicker
    
    if GameLogic.Combat.AutoClicker then
        NexusUI:Notify("Auto Clicker Enabled", 3)
        GameLogic:StartAutoClicker()
    else
        NexusUI:Notify("Auto Clicker Disabled", 3)
    end
end

function GameLogic:StartAutoClicker()
    local clickLoop = RunService.Heartbeat:Connect(function()
        if not GameLogic.Combat.AutoClicker then return end
        
        local character = Player.Character
        if not character then return end
        
        local tool = character:FindFirstChildOfClass("Tool")
        if tool then
            -- Simulate mouse click
            tool:Activate()
        end
    end)
    
    table.insert(GameLogic.AutoFarm.Connections, clickLoop)
end

function GameLogic:ServerHop()
    NexusUI:Notify("Server hopping...", 3)
    
    local servers = {}
    local success, result = pcall(function()
        return HttpService:JSONDecode(game:HttpGet("https://games.roblox.com/v1/games/" .. game.PlaceId .. "/servers/Public?sortOrder=Asc&limit=100"))
    end)
    
    if success and result and result.data then
        for _, server in pairs(result.data) do
            if server.playing < server.maxPlayers and server.id ~= game.JobId then
                table.insert(servers, server)
            end
        end
        
        if #servers > 0 then
            local randomServer = servers[math.random(1, #servers)]
            TeleportService:TeleportToPlaceInstance(game.PlaceId, randomServer.id, Player)
        else
            NexusUI:Notify("No servers found", 3)
        end
    else
        NexusUI:Notify("Failed to get servers", 3)
    end
end

-- ========================================
-- WINDOW CREATION
-- ========================================
function NexusUI:CreateWindow(config)
    config = config or {}
    local window = {
        Tabs = {},
        Title = config.Title or "Nexus Hub",
        Size = config.Size or UDim2.new(0, 550, 0, 600),
        Position = config.Position or UDim2.new(0.5, -275, 0.5, -300)
    }
    
    -- Main Window Container
    local mainContainer = self:Create("Frame", {
        Name = "NexusWindow",
        Size = window.Size,
        Position = window.Position,
        BackgroundColor3 = NexusColors.Background,
        BorderSizePixel = 0,
        ClipsDescendants = true,
        Parent = ScreenGui
    })
    
    self:ApplyNexusStyle(mainContainer, "main")
    
    -- Animated Border
    local border = self:Create("Frame", {
        Size = UDim2.new(1, 8, 1, 8),
        Position = UDim2.new(0, -4, 0, -4),
        BackgroundTransparency = 1,
        ZIndex = 0,
        Parent = mainContainer
    })
    
    local borderCorner = self:Create("UICorner", {
        CornerRadius = UDim.new(0, 12),
        Parent = border
    })
    
    local borderStroke = self:Create("UIStroke", {
        Color = NexusColors.AccentLight,
        Thickness = 3,
        Transparency = 0.3,
        Parent = border
    })
    
    local borderGradient = self:CreateGradient(borderStroke, {
        NexusColors.AccentLight,
        NexusColors.Accent,
        NexusColors.AccentDark,
        NexusColors.AccentLight
    })
    
    -- Animate border
    TweenService:Create(borderGradient, TweenInfo.new(4, Enum.EasingStyle.Linear, Enum.EasingDirection.InOut, -1), {
        Rotation = 360
    }):Play()
    
    -- Header
    local header = self:Create("Frame", {
        Size = UDim2.new(1, 0, 0, 50),
        BackgroundColor3 = NexusColors.Primary,
        BorderSizePixel = 0,
        Parent = mainContainer
    })
    
    self:ApplyNexusStyle(header, "section")
    
    local titleLabel = self:CreateLabel({
        Size = UDim2.new(1, -20, 1, 0),
        Position = UDim2.new(0, 10, 0, 0),
        Text = window.Title,
        TextSize = 18,
        Font = Enum.Font.GothamBlack,
        TextXAlignment = Enum.TextXAlignment.Left,
        Parent = header
    })
    
    local titleGradient = self:CreateGradient(titleLabel, {
        NexusColors.AccentLight,
        NexusColors.Accent,
        NexusColors.AccentDark
    }, 45)
    
    -- Tab Container
    local tabContainer = self:Create("Frame", {
        Size = UDim2.new(1, -20, 1, -70),
        Position = UDim2.new(0, 10, 0, 60),
        BackgroundTransparency = 1,
        Parent = mainContainer
    })
    
    -- Tab Buttons Container
    local tabButtons = self:Create("Frame", {
        Size = UDim2.new(1, 0, 0, 40),
        BackgroundTransparency = 1,
        Parent = mainContainer
    })
    
    local tabListLayout = self:Create("UIListLayout", {
        FillDirection = Enum.FillDirection.Horizontal,
        Padding = UDim.new(0, 5),
        Parent = tabButtons
    })
    
    -- Make draggable
    self:MakeDraggable(header, mainContainer)
    
    function window:AddTab(tabName)
        local tab = {
            Name = tabName,
            Elements = {},
            Container = nil
        }
        
        -- Tab Button
        local tabButton = self:Create("TextButton", {
            Size = UDim2.new(0, 100, 0, 30),
            BackgroundColor3 = NexusColors.Primary,
            Text = tabName,
            TextColor3 = NexusColors.TextPrimary,
            TextSize = 14,
            Font = Enum.Font.GothamBold,
            AutoButtonColor = false,
            Parent = tabButtons
        })
        
        self:ApplyNexusStyle(tabButton, "button")
        NexusUI:AddHoverEffect(tabButton, NexusColors.Primary, NexusColors.HoverPrimary)
        
        -- Tab Content
        local tabContent = self:Create("ScrollingFrame", {
            Size = UDim2.new(1, 0, 1, -10),
            Position = UDim2.new(0, 0, 0, 50),
            BackgroundTransparency = 1,
            ScrollBarThickness = 3,
            ScrollBarImageColor3 = NexusColors.Accent,
            Visible = false,
            Parent = tabContainer
        })
        
        local contentLayout = self:Create("UIListLayout", {
            Padding = UDim.new(0, 10),
            Parent = tabContent
        })
        
        function tab:Show()
            for _, otherTab in pairs(window.Tabs) do
                otherTab.Container.Visible = false
                otherTab.Button.BackgroundColor3 = NexusColors.Primary
            end
            tabContent.Visible = true
            tabButton.BackgroundColor3 = NexusColors.Accent
            NexusUI.ActiveTab = tabName
        end
        
        function tab:Hide()
            tabContent.Visible = false
            tabButton.BackgroundColor3 = NexusColors.Primary
        end
        
        tabButton.MouseButton1Click:Connect(function()
            tab:Show()
        end)
        
        tab.Button = tabButton
        tab.Container = tabContent
        window.Tabs[tabName] = tab
        
        -- Show first tab
        if not NexusUI.ActiveTab then
            tab:Show()
        end
        
        return tab
    end
    
    function window:SetTitle(newTitle)
        window.Title = newTitle
        titleLabel.Text = newTitle
    end
    
    window.Container = mainContainer
    NexusUI.Window = window
    
    return window
end

-- ========================================
-- UI ELEMENTS WITH INTEGRATED LOGIC
-- ========================================
function NexusUI:CreateButton(parent, config)
    config = config or {}
    local button = {
        Text = config.Text or "Button",
        Callback = config.Callback or function() end
    }
    
    local buttonFrame = self:Create("TextButton", {
        Size = UDim2.new(1, -20, 0, 35),
        BackgroundColor3 = NexusColors.ButtonPrimary,
        Text = button.Text,
        TextColor3 = NexusColors.TextPrimary,
        TextSize = 14,
        Font = Enum.Font.GothamBold,
        AutoButtonColor = false,
        Parent = parent
    })
    
    self:ApplyNexusStyle(buttonFrame, "button")
    
    local buttonGradient = self:CreateGradient(buttonFrame, {
        NexusColors.AccentDark,
        NexusColors.Accent
    })
    
    self:AddHoverEffect(buttonFrame, NexusColors.ButtonPrimary, NexusColors.HoverAccent)
    
    buttonFrame.MouseButton1Click:Connect(function()
        self:SafeCallback(button.Callback)
        
        TweenService:Create(buttonFrame, TweenInfo.new(0.1), {
            BackgroundColor3 = NexusColors.AccentLight
        }):Play()
        
        TweenService:Create(buttonFrame, TweenInfo.new(0.1), {
            BackgroundColor3 = NexusColors.ButtonPrimary
        }):Play()
    end)
    
    button.Instance = buttonFrame
    
    function button:SetText(newText)
        button.Text = newText
        buttonFrame.Text = newText
    end
    
    function button:SetVisible(visible)
        buttonFrame.Visible = visible
    end
    
    table.insert(self.Buttons, button)
    return button
end

function NexusUI:CreateToggle(parent, config)
    config = config or {}
    local toggle = {
        Text = config.Text or "Toggle",
        Default = config.Default or false,
        Callback = config.Callback or function() end,
        Value = config.Default or false
    }
    
    local toggleContainer = self:Create("Frame", {
        Size = UDim2.new(1, -20, 0, 30),
        BackgroundTransparency = 1,
        Parent = parent
    })
    
    local toggleLabel = self:CreateLabel({
        Size = UDim2.new(0.7, 0, 1, 0),
        Text = toggle.Text,
        TextSize = 14,
        Parent = toggleContainer
    })
    
    local toggleButton = self:Create("TextButton", {
        Size = UDim2.new(0, 50, 0, 25),
        Position = UDim2.new(0.7, 0, 0, 2),
        BackgroundColor3 = NexusColors.Primary,
        Text = "",
        AutoButtonColor = false,
        Parent = toggleContainer
    })
    
    self:ApplyNexusStyle(toggleButton, "button")
    
    local toggleSwitch = self:Create("Frame", {
        Size = UDim2.new(0, 21, 0, 21),
        Position = UDim2.new(0, 2, 0, 2),
        BackgroundColor3 = NexusColors.TextPrimary,
        Parent = toggleButton
    })
    
    self:ApplyNexusStyle(toggleSwitch, "main")
    
    function toggle:SetValue(value)
        toggle.Value = value
        if value then
            TweenService:Create(toggleSwitch, TweenInfo.new(0.2), {
                Position = UDim2.new(0, 27, 0, 2),
                BackgroundColor3 = NexusColors.Success
            }):Play()
            TweenService:Create(toggleButton, TweenInfo.new(0.2), {
                BackgroundColor3 = NexusColors.Accent
            }):Play()
        else
            TweenService:Create(toggleSwitch, TweenInfo.new(0.2), {
                Position = UDim2.new(0, 2, 0, 2),
                BackgroundColor3 = NexusColors.TextPrimary
            }):Play()
            TweenService:Create(toggleButton, TweenInfo.new(0.2), {
                BackgroundColor3 = NexusColors.Primary
            }):Play()
        end
        self:SafeCallback(toggle.Callback, value)
    end
    
    toggleButton.MouseButton1Click:Connect(function()
        toggle:SetValue(not toggle.Value)
    end)
    
    toggle:SetValue(toggle.Value)
    toggle.Instance = toggleContainer
    self.Toggles[toggle.Text] = toggle
    
    return toggle
end

function NexusUI:CreateSlider(parent, config)
    config = config or {}
    local slider = {
        Text = config.Text or "Slider",
        Min = config.Min or 0,
        Max = config.Max or 100,
        Default = config.Default or 50,
        Callback = config.Callback or function() end,
        Value = config.Default or 50
    }
    
    local sliderContainer = self:Create("Frame", {
        Size = UDim2.new(1, -20, 0, 60),
        BackgroundTransparency = 1,
        Parent = parent
    })
    
    local sliderLabel = self:CreateLabel({
        Size = UDim2.new(1, 0, 0, 20),
        Text = slider.Text,
        TextSize = 14,
        Parent = sliderContainer
    })
    
    local valueLabel = self:CreateLabel({
        Size = UDim2.new(1, 0, 0, 20),
        Position = UDim2.new(0, 0, 0, 20),
        Text = tostring(slider.Value),
        TextSize = 12,
        TextColor3 = NexusColors.TextSecondary,
        Parent = sliderContainer
    })
    
    local sliderTrack = self:Create("Frame", {
        Size = UDim2.new(1, 0, 0, 6),
        Position = UDim2.new(0, 0, 0, 45),
        BackgroundColor3 = NexusColors.Primary,
        Parent = sliderContainer
    })
    
    self:ApplyNexusStyle(sliderTrack, "main")
    
    local sliderFill = self:Create("Frame", {
        Size = UDim2.new(0, 0, 1, 0),
        BackgroundColor3 = NexusColors.Accent,
        Parent = sliderTrack
    })
    
    self:ApplyNexusStyle(sliderFill, "main")
    
    local sliderButton = self:Create("TextButton", {
        Size = UDim2.new(0, 16, 0, 16),
        Position = UDim2.new(0, 0, 0.5, -8),
        BackgroundColor3 = NexusColors.TextPrimary,
        Text = "",
        AutoButtonColor = false,
        Parent = sliderTrack
    })
    
    self:ApplyNexusStyle(sliderButton, "main")
    
    function slider:SetValue(value)
        value = math.clamp(value, slider.Min, slider.Max)
        slider.Value = value
        valueLabel.Text = tostring(value)
        
        local percentage = (value - slider.Min) / (slider.Max - slider.Min)
        sliderFill.Size = UDim2.new(percentage, 0, 1, 0)
        sliderButton.Position = UDim2.new(percentage, -8, 0.5, -8)
        
        self:SafeCallback(slider.Callback, value)
    end
    
    local function updateSlider(input)
        local relativeX = (input.Position.X - sliderTrack.AbsolutePosition.X) / sliderTrack.AbsoluteSize.X
        relativeX = math.clamp(relativeX, 0, 1)
        local value = math.floor(slider.Min + relativeX * (slider.Max - slider.Min))
        slider:SetValue(value)
    end
    
    sliderButton.MouseButton1Down:Connect(function()
        local connection
        connection = UserInputService.InputChanged:Connect(function(input)
            if input.UserInputType == Enum.UserInputType.MouseMovement then
                updateSlider(input)
            end
        end)
        
        UserInputService.InputEnded:Connect(function(input)
            if input.UserInputType == Enum.UserInputType.MouseButton1 then
                connection:Disconnect()
            end
        end)
    end)
    
    sliderTrack.MouseButton1Down:Connect(function(input)
        updateSlider(input)
    end)
    
    slider:SetValue(slider.Value)
    slider.Instance = sliderContainer
    self.Options[slider.Text] = slider
    
    return slider
end

function NexusUI:CreateDropdown(parent, config)
    config = config or {}
    local dropdown = {
        Text = config.Text or "Dropdown",
        Options = config.Options or {"Option 1", "Option 2", "Option 3"},
        Default = config.Default or config.Options[1],
        Callback = config.Callback or function() end,
        Value = config.Default or config.Options[1],
        Open = false
    }
    
    local dropdownContainer = self:Create("Frame", {
        Size = UDim2.new(1, -20, 0, 30),
        BackgroundTransparency = 1,
        Parent = parent
    })
    
    local dropdownButton = self:Create("TextButton", {
        Size = UDim2.new(1, 0, 0, 30),
        BackgroundColor3 = NexusColors.Primary,
        Text = dropdown.Value,
        TextColor3 = NexusColors.TextPrimary,
        TextSize = 14,
        Font = Enum.Font.Gotham,
        AutoButtonColor = false,
        Parent = dropdownContainer
    })
    
    self:ApplyNexusStyle(dropdownButton, "button")
    
    local dropdownArrow = self:Create("ImageLabel", {
        Size = UDim2.new(0, 16, 0, 16),
        Position = UDim2.new(1, -20, 0.5, -8),
        BackgroundTransparency = 1,
        Image = "rbxassetid://6031090990",
        ImageColor3 = NexusColors.TextPrimary,
        Parent = dropdownButton
    })
    
    local dropdownList = self:Create("ScrollingFrame", {
        Size = UDim2.new(1, 0, 0, 0),
        Position = UDim2.new(0, 0, 1, 5),
        BackgroundColor3 = NexusColors.Surface,
        ScrollBarThickness = 3,
        ScrollBarImageColor3 = NexusColors.Accent,
        Visible = false,
        Parent = dropdownContainer
    })
    
    self:ApplyNexusStyle(dropdownList, "main")
    
    local listLayout = self:Create("UIListLayout", {
        Parent = dropdownList
    })
    
    function dropdown:Toggle()
        dropdown.Open = not dropdown.Open
        if dropdown.Open then
            dropdownList.Visible = true
            TweenService:Create(dropdownList, TweenInfo.new(0.2), {
                Size = UDim2.new(1, 0, 0, math.min(#dropdown.Options * 30, 150))
            }):Play()
            TweenService:Create(dropdownArrow, TweenInfo.new(0.2), {
                Rotation = 180
            }):Play()
        else
            TweenService:Create(dropdownList, TweenInfo.new(0.2), {
                Size = UDim2.new(1, 0, 0, 0)
            }):Play()
            TweenService:Create(dropdownArrow, TweenInfo.new(0.2), {
                Rotation = 0
            }):Play()
            wait(0.2)
            dropdownList.Visible = false
        end
    end
    
    function dropdown:SetValue(value)
        dropdown.Value = value
        dropdownButton.Text = value
        self:SafeCallback(dropdown.Callback, value)
        dropdown:Toggle()
    end
    
    for _, option in ipairs(dropdown.Options) do
        local optionButton = self:Create("TextButton", {
            Size = UDim2.new(1, -10, 0, 25),
            BackgroundColor3 = NexusColors.Primary,
            Text = option,
            TextColor3 = NexusColors.TextPrimary,
            TextSize = 12,
            AutoButtonColor = false,
            Parent = dropdownList
        })
        
        self:ApplyNexusStyle(optionButton, "button")
        self:AddHoverEffect(optionButton, NexusColors.Primary, NexusColors.HoverPrimary)
        
        optionButton.MouseButton1Click:Connect(function()
            dropdown:SetValue(option)
        end)
    end
    
    dropdownButton.MouseButton1Click:Connect(function()
        dropdown:Toggle()
    end)
    
    UserInputService.InputBegan:Connect(function(input)
        if dropdown.Open and input.UserInputType == Enum.UserInputType.MouseButton1 then
            local mousePos = input.Position
            local absolutePos = dropdownContainer.AbsolutePosition
            local absoluteSize = dropdownContainer.AbsoluteSize
            
            if not (mousePos.X >= absolutePos.X and mousePos.X <= absolutePos.X + absoluteSize.X and
                   mousePos.Y >= absolutePos.Y and mousePos.Y <= absolutePos.Y + absoluteSize.Y + dropdownList.AbsoluteSize.Y) then
                dropdown:Toggle()
            end
        end
    end)
    
    dropdown.Instance = dropdownContainer
    self.Options[dropdown.Text] = dropdown
    
    return dropdown
end

function NexusUI:CreateLabel(parent, config)
    config = config or {}
    local label = {
        Text = config.Text or "Label",
        TextSize = config.TextSize or 14,
        TextColor = config.TextColor or NexusColors.TextPrimary
    }
    
    local labelFrame = self:CreateLabel({
        Size = UDim2.new(1, -20, 0, 20),
        Text = label.Text,
        TextSize = label.TextSize,
        TextColor3 = label.TextColor,
        Parent = parent
    })
    
    label.Instance = labelFrame
    
    function label:SetText(newText)
        label.Text = newText
        labelFrame.Text = newText
    end
    
    table.insert(self.Labels, label)
    return label
end

-- ========================================
-- DRAGGABLE FUNCTIONALITY
-- ========================================
function NexusUI:MakeDraggable(dragHandle, target)
    local dragging = false
    local dragInput, dragStart, startPos
    
    dragHandle.InputBegan:Connect(function(input)
        if input.UserInputType == Enum.UserInputType.MouseButton1 or input.UserInputType == Enum.UserInputType.Touch then
            dragging = true
            dragStart = input.Position
            startPos = target.Position
            
            input.Changed:Connect(function()
                if input.UserInputState == Enum.UserInputState.End then
                    dragging = false
                end
            end)
        end
    end)
    
    dragHandle.InputChanged:Connect(function(input)
        if input.UserInputType == Enum.UserInputType.MouseMovement or input.UserInputType == Enum.UserInputType.Touch then
            dragInput = input
        end
    end)
    
    UserInputService.InputChanged:Connect(function(input)
        if dragging and input == dragInput then
            local delta = input.Position - dragStart
            target.Position = UDim2.new(
                startPos.X.Scale,
                startPos.X.Offset + delta.X,
                startPos.Y.Scale,
                startPos.Y.Offset + delta.Y
            )
        end
    end)
end

-- ========================================
-- NOTIFICATION SYSTEM
-- ========================================
function NexusUI:Notify(message, duration)
    duration = duration or 5
    
    local notification = self:Create("Frame", {
        Size = UDim2.new(0, 300, 0, 60),
        Position = UDim2.new(1, -320, 1, -80),
        BackgroundColor3 = NexusColors.Surface,
        Parent = ScreenGui
    })
    
    self:ApplyNexusStyle(notification, "main")
    
    local messageLabel = self:CreateLabel({
        Size = UDim2.new(1, -20, 1, -20),
        Position = UDim2.new(0, 10, 0, 10),
        Text = message,
        TextSize = 14,
        TextColor3 = NexusColors.TextPrimary,
        TextWrapped = true,
        Parent = notification
    })
    
    notification.Position = UDim2.new(1, 300, 1, -80)
    TweenService:Create(notification, TweenInfo.new(0.3), {
        Position = UDim2.new(1, -320, 1, -80)
    }):Play()
    
    task.delay(duration, function()
        TweenService:Create(notification, TweenInfo.new(0.3), {
            Position = UDim2.new(1, 300, 1, -80)
        }):Play()
        task.wait(0.3)
        notification:Destroy()
    end)
end

function NexusUI:ToggleUI()
    if self.Window and self.Window.Container then
        self.Toggled = not self.Toggled
        self.Window.Container.Visible = self.Toggled
    end
end

-- ========================================
-- INITIALIZATION AND USAGE
-- ========================================
UserInputService.InputBegan:Connect(function(input)
    if input.KeyCode == Enum.KeyCode.RightShift then
        NexusUI:ToggleUI()
    end
end)

-- Return the library with game logic
NexusUI.GameLogic = GameLogic
return NexusUI
